<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>合成廖建楚</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f7f7f7;
        }

        h1 {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            font-size: 1.5rem;
            color: #333;
            margin: 0;
            font-weight: 600;
        }

        #game-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        /* 下一个预览 */
        #next-fruit-container {
            position: absolute;
            top: 4.5rem;
            right: 1rem;
            z-index: 100;
            width: 3.125rem;
            height: 3.125rem;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #next-fruit-preview {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
            overflow: hidden;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* 游戏主容器 */
        #game-container {
            width: 100%;
            height: 100%;
            background-color: #fff;
            position: relative;
            overflow: hidden;
        }

        /* 游戏结束的红线 */
        #top-line-visual {
            position: absolute;
            top: 60px;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: #FF3B30;
            z-index: 50;
        }

        /* DOM 渲染元素 */
        .fruit-element {
            position: absolute;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            will-change: transform;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        }

        /* 游戏结束浮层 */
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            display: none;
            flex-direction: column; /* 垂直排列 */
            align-items: center; /* 水平居中 */
            justify-content: center; /* 垂直居中，但稍后通过 margin 调整 */
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s;
            padding-top: 5vh; /* 顶部留白，防止文字太靠上 */
        }

        /* 调整游戏结束标题位置，移除绝对定位，让它在flex流中 */
        #game-over-overlay h2 {
            font-size: 2.5rem;
            margin-bottom: 2rem; /* 增加标题和图片之间的距离 */
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            text-align: center; /* 确保文本居中 */
            padding-top: 5vh; /* 额外增加顶部内边距，确保文字在最上方 */
        }

        /* 新增：等级10图片的容器 */
        #level-10-image-container {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            overflow: hidden;
            margin-bottom: 2rem; /* 图片和按钮之间增加间距 */
            border: 8px solid gold; /* 加粗的金色边框 */
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.5); /* 闪耀效果 */
            display: none; /* 默认隐藏 */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            flex-shrink: 0; /* 防止图片容器在小屏幕上缩小 */
        }

        #level-10-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        #restart-button {
            font-size: 1.125rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 50px;
            background-color: #FFD700;
            color: #333;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            /* margin-top: auto; 移除这个，因为我们不再将按钮推到最底部，而是与图片保持一定距离 */
            margin-bottom: 2rem; /* 底部留白 */
        }

        #restart-button:hover {
            background-color: #ffe033;
            transform: scale(1.05);
        }
    </style>
</head>

<body>


    <div id="game-wrapper">
        <div id="game-container">
            <div id="top-line-visual"></div>
        </div>

        <div id="game-over-overlay">
            <h2>游戏结束</h2>
            <div id="level-10-image-container">
                <img id="level-10-image" src="" alt="合成成功">
            </div>
            <button id="restart-button">重新开始</button>
        </div>

        <div id="next-fruit-container">
            <div id="next-fruit-preview"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 1. matter.js 基础设置 ---
            const { Engine, Runner, World, Bodies, Events } = Matter;

            const gameWrapper = document.getElementById('game-wrapper');
            const gameContainer = document.getElementById('game-container');
            const nextFruitPreview = document.getElementById('next-fruit-preview');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const restartButton = document.getElementById('restart-button');
            const gameOverTitle = gameOverOverlay.querySelector('h2');
            const level10ImageContainer = document.getElementById('level-10-image-container'); // 获取图片容器
            const level10Image = document.getElementById('level-10-image'); // 获取图片元素本身


            let width, height;

            function setupGameSize() {
                width = window.innerWidth;
                height = window.innerHeight;
                gameWrapper.style.width = `${width}px`;
                gameWrapper.style.height = `${height}px`;
            }
            setupGameSize();

            window.addEventListener('resize', () => {
                window.location.reload();
            });


            // --- 引擎 ---
            const engine = Engine.create();
            const world = engine.world;
            engine.world.gravity.y = 0.9;
            engine.enableSleeping = true;
            // 🚀 修复穿透 Bug：
            // 增加求解器迭代次数，让碰撞检测更精确
            engine.positionIterations = 8;
            engine.velocityIterations = 6;

            // --- 2. "图片" 数据 ---

            // --- 🌟 修改点 2：调小所有半径 ---
            const FRUITS_DATA = [
                { level: 1, radius: 18, label: "等级1", color: "#FFD700", imageUrl: "../assets/images/create_big_watermelon_game/1.JPG", imgWidth: 339, imgHeight: 464 },
                { level: 2, radius: 22, label: "等级2", color: "#FFA07A", imageUrl: "../assets/images/create_big_watermelon_game/2.JPG", imgWidth: 121, imgHeight: 111 },
                { level: 3, radius: 26, label: "等级3", color: "#20B2AA", imageUrl: "../assets/images/create_big_watermelon_game/3.PNG", imgWidth: 449, imgHeight: 559 },
                { level: 4, radius: 32, label: "等级4", color: "#8A2BE2", imageUrl: "../assets/images/create_big_watermelon_game/4.jpg", imgWidth: 369, imgHeight: 366 },
                { level: 5, radius: 38, label: "等级5", color: "#DC143C", imageUrl: "../assets/images/create_big_watermelon_game/2.JPG", imgWidth: 121, imgHeight: 111 },
                { level: 6, radius: 47, label: "等级6", color: "#006400", imageUrl: "../assets/images/create_big_watermelon_game/5.jpg", imgWidth: 888, imgHeight: 898 },
                { level: 7, radius: 56, label: "等级7", color: "#FF4500", imageUrl: "../assets/images/create_big_watermelon_game/6.JPG", imgWidth: 564, imgHeight: 545 },
                { level: 8, radius: 68, label: "等级8", color: "#4169E1", imageUrl: "../assets/images/create_big_watermelon_game/7.jpg", imgWidth: 381, imgHeight: 409 },
                { level: 9, radius: 83, label: "等级9", color: "#FF1493", imageUrl: "../assets/images/create_big_watermelon_game/8.JPG", imgWidth: 515, imgHeight: 802 },
                { level: 10, radius: 100, label: "等级10", color: "#1E90FF", imageUrl: "../assets/images/create_big_watermelon_game/9.JPG", imgWidth: 108, imgHeight: 103 },
                { level: 11, radius: 120, label: "等级10", color: "#1E90FF", imageUrl: "../assets/images/create_big_watermelon_game/10.JPG", imgWidth: 317, imgHeight: 306 },
//                { level: 11, radius: 120, label: "等级10", color: "#1E90FF", imageUrl: "../assets/images/create_big_watermelon_game/11.JPG", imgWidth: 600, imgHeight: 442 }
            ];
            FRUITS_DATA.forEach(fruit => {
                const img = new Image();
                img.src = fruit.imageUrl;
            });

            const MAX_LEVEL = FRUITS_DATA.length;

            // --- 🌟 修改点 1：从第 5 级开始 ---
            const STARTING_LEVELS = [ 5, 5, 6, 7]; // 原为 [1, 2, 2, 3, 3, 4]

            let currentLevel = 0;
            let nextLevel = 0;
            let canDrop = true;
            let gameOver = false;
            let gameStatus = "playing";
            let gameOverCheckInterval = null;

            // --- 3. 创建边界 (墙和地板) ---
            const wallThickness = 60;

            const ground = Bodies.rectangle(width / 2, height + (wallThickness / 2), width, wallThickness, {
                isStatic: true,
                label: "ground",
                render: { fillStyle: 'transparent' }
            });
            const leftWall = Bodies.rectangle(0 - (wallThickness / 2), height / 2, wallThickness, height, {
                isStatic: true,
                label: "leftWall",
                render: { fillStyle: 'transparent' }
            });
            const rightWall = Bodies.rectangle(width + (wallThickness / 2), height / 2, wallThickness, height, {
                isStatic: true,
                label: "rightWall",
                render: { fillStyle: 'transparent' }
            });

            const topLineY = 60;
            const topLine = Bodies.rectangle(width / 2, topLineY, width, 2, {
                isStatic: true,
                isSensor: true,
                label: "topLine",
                render: { fillStyle: 'transparent' }
            });

            World.add(world, [ground, leftWall, rightWall, topLine]);


            // --- 4. 掉落 "图片" 的功能 (🚀 修复点 1) ---
            // 添加 isDropped 参数，默认为 false
            function addFruit(x, y, level, isDropped = false) {
                if (gameStatus !== "playing") return;

                const data = FRUITS_DATA.find(f => f.level === level);
                if (!data) return;

                const fruitBody = Bodies.circle(x, y, data.radius, {
                    label: `fruit-${data.level}`,
                    restitution: 0.2,
                    friction: 0.1,
                    density: 0.001
                });

                const fruitElement = document.createElement('div');
                fruitElement.classList.add('fruit-element');
                fruitElement.style.width = `${data.radius * 2}px`;
                fruitElement.style.height = `${data.radius * 2}px`;
                fruitElement.style.backgroundImage = `url('${data.imageUrl}')`;

                fruitBody.element = fruitElement;
                gameContainer.appendChild(fruitElement);

                // --- 🚀 修复点 2：逻辑修改 ---
                // 只有玩家亲手 "Dropped" (isDropped = true) 的水果才有宽限期
                // 合并 (merge) 产生的水果 (isDropped = false) 必须立即接受失败检查
                if (isDropped) {
                    fruitBody.isNew = true;
                    setTimeout(() => {
                        if (fruitBody.world) {
                            fruitBody.isNew = false;
                        }
                    }, 500); // 宽限期可以设置长一点，只对玩家操作生效
                } else {
                    fruitBody.isNew = false; // 合并产生的水果，立即生效
                }

                World.add(world, fruitBody);
                return fruitBody;
            }

            // --- 5. "下一个" 逻辑 ---
            function setNextFruit() {
                if (currentLevel === 0) {
                    currentLevel = STARTING_LEVELS[Math.floor(Math.random() * STARTING_LEVELS.length)];
                } else {
                    currentLevel = nextLevel;
                }
                nextLevel = STARTING_LEVELS[Math.floor(Math.random() * STARTING_LEVELS.length)];

                const currentData = FRUITS_DATA.find(f => f.level === currentLevel);
                if (currentData) {
                    nextFruitPreview.innerHTML = '';
                    // 使用 currentData.imageUrl 来设置预览
                    nextFruitPreview.style.backgroundImage = `url('${currentData.imageUrl}')`;
                    nextFruitPreview.style.opacity = '1';
                }
            }

            // --- 6. 添加点击事件 (🚀 修复点 3) ---
            function handleDrop(event) {
                if (!canDrop || gameOver || gameStatus !== "playing") return;
                event.preventDefault();

                let x;
                if (event.type.startsWith('touch')) {
                    const touch = event.touches[0] || event.changedTouches[0];
                    x = touch.clientX - gameContainer.getBoundingClientRect().left;
                } else {
                    x = event.offsetX;
                }

                const data = FRUITS_DATA.find(f => f.level === currentLevel);
                if (!data) return;

                const minX = data.radius;
                const maxX = width - data.radius;

                x = Math.max(minX, Math.min(x, maxX));

                // --- 🚀 修复点 3：调用 addFruit 时传入 'true' ---
                addFruit(x, 25, currentLevel, true);

                setNextFruit();

                canDrop = false;
                setTimeout(() => {
                    canDrop = true;
                }, 100);
            }

            gameContainer.addEventListener('mousedown', handleDrop);
            gameContainer.addEventListener('touchstart', handleDrop, { passive: false });


            // --- 7. 核心：合并逻辑 ---
            Events.on(engine, 'collisionStart', (event) => {
                if (gameOver || gameStatus !== "playing") return;

                const pairs = event.pairs;
                for (let i = 0; i < pairs.length; i++) {
                    const { bodyA, bodyB } = pairs[i];
                    if (bodyA.label.startsWith('fruit-') && bodyB.label === bodyA.label) {
                        const currentLevel = parseInt(bodyA.label.split('-')[1]);
                        if (currentLevel === MAX_LEVEL) continue;
                        const nextLevel = currentLevel + 1;

                        if (bodyA.element) bodyA.element.remove();
                        if (bodyB.element) bodyB.element.remove();

                        World.remove(world, [bodyA, bodyB]);

                        const newX = (bodyA.position.x + bodyB.position.x) / 2;
                        const newY = (bodyA.position.y + bodyB.position.y) / 2;

                        setTimeout(() => {
                            // 调用 addFruit 时不传 'true'，isDropped 默认为 false
                            const newFruit = addFruit(newX, newY, nextLevel);

                            if (newFruit && nextLevel === MAX_LEVEL && gameStatus === "playing") {
                                triggerGameOver("success");
                            }
                        }, 50);
                    }
                }
            });

            // --- 8. 游戏结束逻辑 (使用最开始的干净版本) ---
            function checkGameOver() {
                if (gameOver || gameStatus !== "playing") return;

                const allFruits = world.bodies.filter(body => body.label.startsWith('fruit-'));
                for (const fruit of allFruits) {
                    // 只跳过玩家刚扔下的
                    if (fruit.isNew) continue;
                    const topEdgeY = fruit.position.y - fruit.circleRadius;
                    if (topEdgeY < topLineY) {
                        triggerGameOver("failure");
                        break;
                    }
                }
            }

            // --- 9. 触发结束 ---
            function triggerGameOver(status) {
                if (gameOver || gameStatus !== "playing") return;

                console.log(`游戏结束: ${status}`);
                gameOver = true;
                gameStatus = status;

                if (gameOverCheckInterval) {
                    clearInterval(gameOverCheckInterval);
                }
                Runner.stop(runner);

                if (status === "success") {
                    gameOverTitle.textContent = "恭喜！合成成功！";
                    // 找到等级10的图片数据
                    const level10Data = FRUITS_DATA.find(f => f.level === MAX_LEVEL);
                    if (level10Data) {
                        level10Image.src = level10Data.imageUrl;
                        level10ImageContainer.style.display = 'flex'; // 显示图片容器
                    }
                } else {
                    gameOverTitle.textContent = "游戏失败";
                    level10ImageContainer.style.display = 'none'; // 失败时隐藏图片
                }

                gameOverOverlay.style.display = 'flex';
                setTimeout(() => {
                    gameOverOverlay.style.opacity = '1';
                }, 10);
            }

            // --- 10. 游戏重启逻辑 ---
            function restartGame() {
                console.log("游戏重启...");
                gameOverOverlay.style.opacity = '0';
                setTimeout(() => {
                    gameOverOverlay.style.display = 'none';
                    gameOverTitle.textContent = "游戏结束";
                    level10ImageContainer.style.display = 'none'; // 隐藏图片
                }, 500);

                gameOver = false;
                gameStatus = "playing";
                canDrop = true;

                const allFruitElements = document.querySelectorAll('.fruit-element');
                allFruitElements.forEach(el => el.remove());
                const allFruitBodies = world.bodies.filter(body => body.label.startsWith('fruit-'));
                World.remove(world, allFruitBodies);

                Runner.run(runner, engine);
                currentLevel = 0;
                setNextFruit();
                startGameLoop();
            }
            restartButton.addEventListener('click', restartGame);

            // --- 11. 运行引擎 和 渲染循环 ---
            const runner = Runner.create();
            Runner.run(runner, engine);

            Events.on(engine, 'afterUpdate', () => {
                const fruits = world.bodies.filter(body => body.element);
                for (const fruit of fruits) {
                    const { x, y } = fruit.position;
                    const angle = fruit.angle;
                    const xPos = x - fruit.circleRadius;
                    const yPos = y - fruit.circleRadius;
                    fruit.element.style.transform = `translate(${xPos}px, ${yPos}px) rotate(${angle}rad)`;
                }
            });

            // 启动游戏主循环
            function startGameLoop() {
                setNextFruit();
                if (gameOverCheckInterval) {
                    clearInterval(gameOverCheckInterval);
                }
                // 检查间隔可以放回 1000ms，因为 Bug 已经修复
                gameOverCheckInterval = setInterval(checkGameOver, 1000);
            }

            // 开始游戏
            startGameLoop();
        });
    </script>

    <div class="fixed bottom-4 right-4 z-[200]"> <a href="/"
            class="bg-purple-600 hover:bg-purple-700 text-white font-bold p-3 rounded-full shadow-lg flex items-center justify-center transition-all duration-300 ease-in-out transform hover:scale-105">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
            </svg>
        </a>
    </div>
</body>

</html>