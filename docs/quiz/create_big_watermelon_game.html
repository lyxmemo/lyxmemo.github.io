<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>åˆæˆå»–å»ºæ¥š</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        /* CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f7f7f7;
        }

        h1 {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            font-size: 1.5rem;
            color: #333;
            margin: 0;
            font-weight: 600;
        }

        #game-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }

        /* ä¸‹ä¸€ä¸ªé¢„è§ˆ */
        #next-fruit-container {
            position: absolute;
            top: 4.5rem;
            /* 72px, ä½äºçº¢çº¿ (60px) ä¹‹ä¸‹ */
            right: 1rem;
            /* 16px, è·ç¦»å³è¾¹ç¼˜ */
            z-index: 100;

            width: 3.125rem;
            height: 3.125rem;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #next-fruit-preview {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s;
            overflow: hidden;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* æ¸¸æˆä¸»å®¹å™¨ */
        #game-container {
            width: 100%;
            height: 100%;
            background-color: #fff;
            position: relative;
            overflow: hidden;
        }

        /* æ¸¸æˆç»“æŸçš„çº¢çº¿ */
        #top-line-visual {
            position: absolute;
            top: 60px;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: #FF3B30;
            z-index: 50;
        }

        /* DOM æ¸²æŸ“å…ƒç´  */
        .fruit-element {
            position: absolute;
            border-radius: 50%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            will-change: transform;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
        }


        /* æ¸¸æˆç»“æŸæµ®å±‚ */
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.5s;
        }

        #game-over-overlay h2 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #restart-button {
            font-size: 1.125rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 50px;
            background-color: #FFD700;
            color: #333;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #restart-button:hover {
            background-color: #ffe033;
            transform: scale(1.05);
        }
    </style>
</head>

<body>


    <div id="game-wrapper">
        <div id="game-container">
            <div id="top-line-visual"></div>
        </div>

        <div id="game-over-overlay">
            <h2>æ¸¸æˆç»“æŸ</h2>
            <button id="restart-button">é‡æ–°å¼€å§‹</button>
        </div>

        <div id="next-fruit-container">
            <div id="next-fruit-preview"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- 1. matter.js åŸºç¡€è®¾ç½® ---
            const { Engine, Runner, World, Bodies, Events } = Matter;

            const gameWrapper = document.getElementById('game-wrapper');
            const gameContainer = document.getElementById('game-container');
            const nextFruitPreview = document.getElementById('next-fruit-preview');
            const gameOverOverlay = document.getElementById('game-over-overlay');
            const restartButton = document.getElementById('restart-button');
            const gameOverTitle = gameOverOverlay.querySelector('h2');

            let width, height;

            function setupGameSize() {
                width = window.innerWidth;
                height = window.innerHeight;
                gameWrapper.style.width = `${width}px`;
                gameWrapper.style.height = `${height}px`;
            }
            setupGameSize();

            window.addEventListener('resize', () => {
                window.location.reload();
            });


            // --- å¼•æ“ ---
            const engine = Engine.create();
            const world = engine.world;
            engine.world.gravity.y = 0.9;
            engine.enableSleeping = true;
            // ğŸš€ ä¿®å¤ç©¿é€ Bugï¼š
            // å¢åŠ æ±‚è§£å™¨è¿­ä»£æ¬¡æ•°ï¼Œè®©ç¢°æ’æ£€æµ‹æ›´ç²¾ç¡®
            engine.positionIterations = 8;
            engine.velocityIterations = 6;

            // --- 2. "å›¾ç‰‡" æ•°æ® ---
            const FRUITS_DATA = [
                { level: 1, radius: 30, label: "ç­‰çº§1", color: "#FFD700", imageUrl: "../assets/images/create_big_watermelon_game/1.JPG", imgWidth: 339, imgHeight: 464 },
                { level: 2, radius: 36, label: "ç­‰çº§2", color: "#FFA07A", imageUrl: "../assets/images/create_big_watermelon_game/2.JPG", imgWidth: 121, imgHeight: 111 },
                { level: 3, radius: 44, label: "ç­‰çº§3", color: "#20B2AA", imageUrl: "../assets/images/create_big_watermelon_game/3.PNG", imgWidth: 449, imgHeight: 559 },
                { level: 4, radius: 53, label: "ç­‰çº§4", color: "#8A2BE2", imageUrl: "../assets/images/create_big_watermelon_game/4.jpg", imgWidth: 369, imgHeight: 366 },
                { level: 5, radius: 65, label: "ç­‰çº§5", color: "#DC143C", imageUrl: "../assets/images/create_big_watermelon_game/5.jpg", imgWidth: 888, imgHeight: 898 },
                { level: 6, radius: 78, label: "ç­‰çº§6", color: "#006400", imageUrl: "../assets/images/create_big_watermelon_game/6.JPG", imgWidth: 564, imgHeight: 545 },
                { level: 7, radius: 95, label: "ç­‰çº§7", color: "#FF4500", imageUrl: "../assets/images/create_big_watermelon_game/7.jpg", imgWidth: 381, imgHeight: 409 },
                { level: 8, radius: 116, label: "ç­‰çº§8", color: "#4169E1", imageUrl: "../assets/images/create_big_watermelon_game/8.JPG", imgWidth: 515, imgHeight: 802 },
                { level: 9, radius: 141, label: "ç­‰çº§9", color: "#FF1493", imageUrl: "../assets/images/create_big_watermelon_game/9.JPG", imgWidth: 108, imgHeight: 103 },
                { level: 10, radius: 173, label: "ç­‰çº§10", color: "#1E90FF", imageUrl: "../assets/images/create_big_watermelon_game/10.JPG", imgWidth: 317, imgHeight: 306 },
                { level: 11, radius: 210, label: "ç­‰çº§11", color: "#32CD32", imageUrl: "../assets/images/create_big_watermelon_game/11.JPG", imgWidth: 600, imgHeight: 442 }
            ];
            FRUITS_DATA.forEach(fruit => {
                const img = new Image();
                img.src = fruit.imageUrl;
            });

            const MAX_LEVEL = FRUITS_DATA.length;
            const STARTING_LEVELS = [1, 1, 1, 2, 2, 3];

            let currentLevel = 0;
            let nextLevel = 0;
            let canDrop = true;
            let gameOver = false;
            let gameStatus = "playing";
            let gameOverCheckInterval = null;

            // --- 3. åˆ›å»ºè¾¹ç•Œ (å¢™å’Œåœ°æ¿) ---
            const wallThickness = 60;

            const ground = Bodies.rectangle(width / 2, height + (wallThickness / 2), width, wallThickness, {
                isStatic: true,
                label: "ground",
                render: { fillStyle: 'transparent' }
            });
            const leftWall = Bodies.rectangle(0 - (wallThickness / 2), height / 2, wallThickness, height, {
                isStatic: true,
                label: "leftWall",
                render: { fillStyle: 'transparent' }
            });
            const rightWall = Bodies.rectangle(width + (wallThickness / 2), height / 2, wallThickness, height, {
                isStatic: true,
                label: "rightWall",
                render: { fillStyle: 'transparent' }
            });

            const topLineY = 60;
            const topLine = Bodies.rectangle(width / 2, topLineY, width, 2, {
                isStatic: true,
                isSensor: true,
                label: "topLine",
                render: { fillStyle: 'transparent' }
            });

            World.add(world, [ground, leftWall, rightWall, topLine]);


            // --- 4. æ‰è½ "å›¾ç‰‡" çš„åŠŸèƒ½ (ğŸš€ ä¿®å¤ç‚¹ 1) ---
            // æ·»åŠ  isDropped å‚æ•°ï¼Œé»˜è®¤ä¸º false
            function addFruit(x, y, level, isDropped = false) {
                if (gameStatus !== "playing") return;

                const data = FRUITS_DATA.find(f => f.level === level);
                if (!data) return;

                const fruitBody = Bodies.circle(x, y, data.radius, {
                    label: `fruit-${data.level}`,
                    restitution: 0.2,
                    friction: 0.1,
                    density: 0.001
                });

                const fruitElement = document.createElement('div');
                fruitElement.classList.add('fruit-element');
                fruitElement.style.width = `${data.radius * 2}px`;
                fruitElement.style.height = `${data.radius * 2}px`;
                fruitElement.style.backgroundImage = `url('${data.imageUrl}')`;

                fruitBody.element = fruitElement;
                gameContainer.appendChild(fruitElement);

                // --- ğŸš€ ä¿®å¤ç‚¹ 2ï¼šé€»è¾‘ä¿®æ”¹ ---
                // åªæœ‰ç©å®¶äº²æ‰‹ "Dropped" (isDropped = true) çš„æ°´æœæ‰æœ‰å®½é™æœŸ
                // åˆå¹¶ (merge) äº§ç”Ÿçš„æ°´æœ (isDropped = false) å¿…é¡»ç«‹å³æ¥å—å¤±è´¥æ£€æŸ¥
                if (isDropped) {
                    fruitBody.isNew = true;
                    setTimeout(() => {
                        if (fruitBody.world) {
                            fruitBody.isNew = false;
                        }
                    }, 500); // å®½é™æœŸå¯ä»¥è®¾ç½®é•¿ä¸€ç‚¹ï¼Œåªå¯¹ç©å®¶æ“ä½œç”Ÿæ•ˆ
                } else {
                    fruitBody.isNew = false; // åˆå¹¶äº§ç”Ÿçš„æ°´æœï¼Œç«‹å³ç”Ÿæ•ˆ
                }

                World.add(world, fruitBody);
                return fruitBody;
            }

            // --- 5. "ä¸‹ä¸€ä¸ª" é€»è¾‘ ---
            function setNextFruit() {
                if (currentLevel === 0) {
                    currentLevel = STARTING_LEVELS[Math.floor(Math.random() * STARTING_LEVELS.length)];
                } else {
                    currentLevel = nextLevel;
                }
                nextLevel = STARTING_LEVELS[Math.floor(Math.random() * STARTING_LEVELS.length)];

                const nextData = FRUITS_DATA.find(f => f.level === nextLevel);
                if (nextData) {
                    nextFruitPreview.innerHTML = '';
                    nextFruitPreview.style.backgroundImage = `url('${nextData.imageUrl}')`;
                    nextFruitPreview.style.opacity = '1';
                }
            }

            // --- 6. æ·»åŠ ç‚¹å‡»äº‹ä»¶ (ğŸš€ ä¿®å¤ç‚¹ 3) ---
            function handleDrop(event) {
                if (!canDrop || gameOver || gameStatus !== "playing") return;
                event.preventDefault();

                let x;
                if (event.type.startsWith('touch')) {
                    const touch = event.touches[0] || event.changedTouches[0];
                    x = touch.clientX - gameContainer.getBoundingClientRect().left;
                } else {
                    x = event.offsetX;
                }

                const data = FRUITS_DATA.find(f => f.level === currentLevel);
                if (!data) return;

                const minX = data.radius;
                const maxX = width - data.radius;

                x = Math.max(minX, Math.min(x, maxX));

                // --- ğŸš€ ä¿®å¤ç‚¹ 3ï¼šè°ƒç”¨ addFruit æ—¶ä¼ å…¥ 'true' ---
                addFruit(x, 25, currentLevel, true);

                setNextFruit();

                canDrop = false;
                setTimeout(() => {
                    canDrop = true;
                }, 100);
            }

            gameContainer.addEventListener('mousedown', handleDrop);
            gameContainer.addEventListener('touchstart', handleDrop, { passive: false });


            // --- 7. æ ¸å¿ƒï¼šåˆå¹¶é€»è¾‘ ---
            Events.on(engine, 'collisionStart', (event) => {
                if (gameOver || gameStatus !== "playing") return;

                const pairs = event.pairs;
                for (let i = 0; i < pairs.length; i++) {
                    const { bodyA, bodyB } = pairs[i];
                    if (bodyA.label.startsWith('fruit-') && bodyB.label === bodyA.label) {
                        const currentLevel = parseInt(bodyA.label.split('-')[1]);
                        if (currentLevel === MAX_LEVEL) continue;
                        const nextLevel = currentLevel + 1;

                        if (bodyA.element) bodyA.element.remove();
                        if (bodyB.element) bodyB.element.remove();

                        World.remove(world, [bodyA, bodyB]);

                        const newX = (bodyA.position.x + bodyB.position.x) / 2;
                        const newY = (bodyA.position.y + bodyB.position.y) / 2;

                        setTimeout(() => {
                            // è°ƒç”¨ addFruit æ—¶ä¸ä¼  'true'ï¼ŒisDropped é»˜è®¤ä¸º false
                            const newFruit = addFruit(newX, newY, nextLevel);

                            if (newFruit && nextLevel === MAX_LEVEL && gameStatus === "playing") {
                                triggerGameOver("success");
                            }
                        }, 50);
                    }
                }
            });

            // --- 8. æ¸¸æˆç»“æŸé€»è¾‘ (ä½¿ç”¨æœ€å¼€å§‹çš„å¹²å‡€ç‰ˆæœ¬) ---
            function checkGameOver() {
                if (gameOver || gameStatus !== "playing") return;

                const allFruits = world.bodies.filter(body => body.label.startsWith('fruit-'));
                for (const fruit of allFruits) {
                    // åªè·³è¿‡ç©å®¶åˆšæ‰”ä¸‹çš„
                    if (fruit.isNew) continue;
                    const topEdgeY = fruit.position.y - fruit.circleRadius;
                    if (topEdgeY < topLineY) {
                        triggerGameOver("failure");
                        break;
                    }
                }
            }

            // --- 9. è§¦å‘ç»“æŸ ---
            function triggerGameOver(status) {
                if (gameOver || gameStatus !== "playing") return;

                console.log(`æ¸¸æˆç»“æŸ: ${status}`);
                gameOver = true;
                gameStatus = status;

                if (gameOverCheckInterval) {
                    clearInterval(gameOverCheckInterval);
                }
                Runner.stop(runner);

                if (status === "success") {
                    gameOverTitle.textContent = "æ­å–œï¼åˆæˆæˆåŠŸï¼";
                } else {
                    gameOverTitle.textContent = "æ¸¸æˆå¤±è´¥";
                }

                gameOverOverlay.style.display = 'flex';
                setTimeout(() => {
                    gameOverOverlay.style.opacity = '1';
                }, 10);
            }

            // --- 10. æ¸¸æˆé‡å¯é€»è¾‘ ---
            function restartGame() {
                console.log("æ¸¸æˆé‡å¯...");
                gameOverOverlay.style.opacity = '0';
                setTimeout(() => {
                    gameOverOverlay.style.display = 'none';
                    gameOverTitle.textContent = "æ¸¸æˆç»“æŸ";
                }, 500);

                gameOver = false;
                gameStatus = "playing";
                canDrop = true;

                const allFruitElements = document.querySelectorAll('.fruit-element');
                allFruitElements.forEach(el => el.remove());
                const allFruitBodies = world.bodies.filter(body => body.label.startsWith('fruit-'));
                World.remove(world, allFruitBodies);

                Runner.run(runner, engine);
                currentLevel = 0;
                setNextFruit();
                startGameLoop();
            }
            restartButton.addEventListener('click', restartGame);

            // --- 11. è¿è¡Œå¼•æ“ å’Œ æ¸²æŸ“å¾ªç¯ ---
            const runner = Runner.create();
            Runner.run(runner, engine);

            Events.on(engine, 'afterUpdate', () => {
                const fruits = world.bodies.filter(body => body.element);
                for (const fruit of fruits) {
                    const { x, y } = fruit.position;
                    const angle = fruit.angle;
                    const xPos = x - fruit.circleRadius;
                    const yPos = y - fruit.circleRadius;
                    fruit.element.style.transform = `translate(${xPos}px, ${yPos}px) rotate(${angle}rad)`;
                }
            });

            // å¯åŠ¨æ¸¸æˆä¸»å¾ªç¯
            function startGameLoop() {
                setNextFruit();
                if (gameOverCheckInterval) {
                    clearInterval(gameOverCheckInterval);
                }
                // æ£€æŸ¥é—´éš”å¯ä»¥æ”¾å› 1000msï¼Œå› ä¸º Bug å·²ç»ä¿®å¤
                gameOverCheckInterval = setInterval(checkGameOver, 1000);
            }

            // å¼€å§‹æ¸¸æˆ
            startGameLoop();
        });
    </script>

    <div class="fixed bottom-4 right-4 z-[200]"> <a href="/"
            class="bg-purple-600 hover:bg-purple-700 text-white font-bold p-3 rounded-full shadow-lg flex items-center justify-center transition-all duration-300 ease-in-out transform hover:scale-105">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
            </svg>
        </a>
    </div>
</body>

</html>